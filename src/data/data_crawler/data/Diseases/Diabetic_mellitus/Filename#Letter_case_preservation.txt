A filename or file name is a name used to uniquely identify a computer file in a file system. Different file systems impose different restrictions on filename lengths.A filename may  include:The components required to identify a file by utilities and applications varies across operating systems, as does the syntax and format for a valid filename.Filenames may contain any arbitrary bytes the user chooses. This may include things like a revision or generation number of the file such as computer code, a numerical sequence number , a date and time , and/or a comment such as the name of a subject or a location or any other text to facilitate the searching the files. In fact, even unprintable characters, including bell, 0x00, Return and LineFeed can be part of a filename, although most utilities do not handle them well.Some people use of the term filename when referring to a complete specification of device, subdirectories and filename such as the Windows C:\Program Files\Microsoft Games\Chess\Chess.exe. The filename in this case is Chess.exe. Some utilities have settings to suppress the extension as with MS Windows Explorer.On early personal computers using the CP/M operating system, with the File Allocation Table  filesystem, filenames were always 11 characters. This was referred to as the 8.3 filename with a maximum of an 8 byte name and a maximum of a 3 byte extension. Utilities and applications allowed users to specify filenames without trailing spaces and include a dot before the extension.  The dot was not actually stored in the directory. Using only 7 bit characters allowed several file attributes to be included in the actual filename by using the high-order-bit. These attributes included Readonly, Archive, HIDDEN and SYS. Eventually this was too restrictive and the number of characters allowed increased. The attribute bits were moved to a special block of the file including additional information. This led to compatibility problems when moving files between different file systems.During the 1970s, some mainframe and minicomputers  where files on the system were identified by a user name, or account number.For example, on Digital Equipment Corporation RSTS/E and TOPS-10 operating systems, files were identified byOn the IBM OS/VS1, OS/390 and MVS operating systems, a file name was up to 44 characters, consisting of upper case letters, digits, and the period. A file name must start with a letter or number, a period must occur at least once each 8 characters, two consecutive periods could not appear in the name, and must end with a letter or digit. By convention, the letters and numbers before the first period was the account number of the owner or the project it belonged to, but there was no requirement to use this convention.On the McGill University MUSIC/SP system, file names consisted ofThe Univac VS/9 operating system had file names consisting ofIn 1985, RFC 959 officially defined a pathname to be the character string that must be entered into a file system by a user in order to identify a file.Around 1995, VFAT, an extension to the MS-DOS FAT filesystem, was introduced in Windows 95 and Windows NT. It allowed mixed-case Unicode long filenames , in addition to classic "8.3" names.An absolute reference includes all directory levels. In some systems, a filename reference that does not include the complete directory path defaults to the current working directory. This is a relative reference. One advantage of using a relative reference in program configuration files or scripts is that different instances of the script or program can use different files.This makes an absolute or relative path composed of a sequence of filenames.Unix-like file systems allow a file to have more than one name; in traditional Unix-style file systems, the names are hard links to the file's inode or equivalent. Windows supports hard links on NTFS file systems, and provides the command fsutil in Windows XP, and mklink in later versions, for creating them. Hard links are different from Windows shortcuts, classic Mac OS/macOS aliases, or symbolic links. The introduction of LFNs with VFAT allowed filename aliases. For example, longfi~1.??? with a maximum of eight plus three characters was a filename alias of "long file name.???" as a way to conform to 8.3 limitations for older programs.This property was used by the move command algorithm that first creates a second filename and then only removes the first filename.Other filesystems, by design, provide only one filename per file, which guarantees that alteration of one filename's file does not alter the other filename's file.Some filesystems restrict the length of filenames. In some cases, these lengths apply to the entire file name, as in 44 characters on IBM S/370. In other cases, the length limits may apply to particular portions of the filename, such as the name of a file in a directory, or a directory name. For example, 9 , 11 , 14 , 21 , 31, 30 , 15 , 44 , or 255  characters or bytes. Length limits often result from assigning fixed space in a filesystem to storing components of names, so increasing limits often requires an incompatible change, as well as reserving more space.A particular issue with filesystems that store information in nested directories is that it may be possible to create a file with a complete pathname that exceeds implementation limits, since length checking may apply only to individual parts of the name rather than the entire name. Many Windows applications are limited to a MAX_PATH value of 260, but Windows file names can easily exceed this limit . From Windows 10, version 1607, MAX_PATH limitations have been removed.Many file systems, including FAT, NTFS, and VMS systems, consider as filename extension the part of the file name that consists of one or more characters following the last period in the filename, dividing the filename into two parts: a base name or stem and an extension or suffix used by some applications to indicate the file type. Multiple output files created by an application use the same basename and various extensions. For example, a compiler might use the extension FOR for source input file , OBJ for the object output and LST for the listing. Although there are some common extensions, they are arbitrary and a different application might use REL and RPT. Extensions have been restricted, at least historically on some systems, to a length of 3 characters, but in general can have any length, e.g., html.There is no general encoding standard for filenames.File names have to be exchanged between software environments for network file transfer, file system storage, backup and file synchronization software, configuration management, data compression and archiving, etc. It is thus very important not to lose file name information between applications. This led to wide adoption of Unicode as a standard for encoding file names, although legacy software might not be Unicode-aware.Traditionally, filenames allowed any character in their filenames as long as they were file system safe. Although this permitted the use of any encoding, and thus allowed the representation of any local text on any local system, it caused many interoperability issues.A filename could be stored using different byte strings in distinct systems within a single country, such as if one used Japanese Shift JIS encoding and another Japanese EUC encoding. Conversion was not possible as most systems did not expose a description of the encoding used for a filename as part of the extended file information. This forced costly filename encoding guessing with each file access.A solution was to adopt Unicode as the encoding for filenames.In the classic Mac OS, however, encoding of the filename was stored with the filename attributes.The Unicode standard solves the encoding determination issue.Nonetheless, some limited interoperability issues remain, such as normalization , or the Unicode version in use. For instance, UDF is limited to Unicode 2.0; macOS's HFS+ file system applies NFD Unicode normalization and is optionally case-sensitive  Filename maximum length is not standard and might depend on the code unit size. Although it is a serious issue, in most cases this is a limited one.On Linux, this means the filename is not enough to open a file: additionally, the exact byte representation of the filename on the storage device is needed. This can be solved at the application level, with some tricky normalization calls.The issue of Unicode equivalence is known as "normalized-name collision". A solution is the Non-normalizing Unicode Composition Awareness used in the Subversion and Apache technical communities. This solution does not normalize paths in the repository. Paths are only normalized for the purpose of comparisons. Nonetheless, some communities have patented this strategy, forbidding its use by other communities.To limit interoperability issues, some ideas described by Sun are to:Those considerations create a limitation not allowing a switch to a future encoding different from UTF-8.One issue was migration to Unicode.
For this purpose, several software companies provided software for migrating filenames to the new Unicode encoding.Mac OS X 10.3 marked Apple's adoption of Unicode 3.2 character decomposition, superseding the Unicode 2.1 decomposition used previously. This change caused problems for developers writing software for Mac OS X.Within a single directory, filenames must be unique. Since the filename syntax also applies for directories, it is not possible to create a file and directory entries with the same name in a single directory. Multiple files in different directories may have the same name.Uniqueness approach may differ both on the case sensitivity and on the Unicode normalization form such as NFC, NFD.
This means two separate files might be created with the same text filename and a different byte implementation of the filename, such as L"\x00C0.txt"   and L"\x0041\x0300.txt"  .Some filesystems, such as FAT, store filenames as upper-case regardless of the letter case used to create them. For example, a file created with the name "MyName.Txt" or "myname.txt" would be stored with the filename "MYNAME.TXT". Any variation of upper and lower case can be used to refer to the same file. These kinds of file systems are called case-insensitive and are not case-preserving. Some filesystems prohibit the use of lower case letters in filenames altogether.Some file systems store filenames in the form that they were originally created; these are referred to as case-retentive or case-preserving. Such a file system can be case-sensitive or case-insensitive. If case-sensitive, then "MyName.Txt" and "myname.txt" may refer to two different files in the same directory, and each file must be referenced by the exact capitalization by which it is named. On a case-insensitive, case-preserving file system, on the other hand, only one of "MyName.Txt", "myname.txt" and "Myname.TXT" can be the name of a file in a given directory at a given time, and a file with one of these names can be referenced by any capitalization of the name.From its original inception, Unix and its derivative systems were case-preserving. However, not all Unix-like file systems are case-sensitive; by default, HFS+ in macOS is case-insensitive, and SMB servers usually provide case-insensitive behavior , and SMB client file systems provide case-insensitive behavior. File system case sensitivity is a considerable challenge for software such as Samba and Wine, which must interoperate efficiently with both systems that treat uppercase and lowercase files as different and with systems that treat them the same.File systems have not always provided the same character set for composing a filename. Before Unicode became a de facto standard, file systems mostly used a locale-dependent character set. By contrast, some new systems permit a filename to be composed of almost any character of the Unicode repertoire, and even some non-Unicode byte sequences. Limitations may be imposed by the file system, operating system, application, or requirements for interoperability with other systems.Many file system utilities prohibit control characters from appearing in filenames. In Unix-like file systems, the null character and the path separator / are prohibited.File system utilities and naming conventions on various systems prohibit particular characters from appearing in filenames or make them problematic:Note 1: While they are allowed in Unix file and folder names, most Unix shells require specific characters such as spaces, <, >, |, \, and sometimes :, , &, ;, #, as well as wildcards such as ? and *, to be quoted or escaped:five\ and\ six\<seven 'five and six<seven' or "five and six<seven" The character å  was not allowed as the first letter in a filename under 86-DOS and MS-DOS/PC DOS 1.x-2.x, but can be used in later versions.In Windows utilities, the space and the period are not allowed as the final character of a filename. The period is allowed as the first character, but some Windows applications, such as Windows Explorer, forbid creating or renaming such files . Workarounds include appending a dot when renaming the file , using alternative file managers, creating the file using the command line, or saving a file with the desired filename from within an application.Some file systems on a given operating system , and particular applications on that operating system, may apply further restrictions and interpretations. See comparison of file systems for more details on restrictions.In Unix-like systems, DOS, and Windows, the filenames "." and ".." have special meanings . Windows 95/98/ME also uses names like "...", "...." and so on to denote grandparent or great-grandparent directories. All Windows versions forbid creation of filenames that consist of only dots, although names consist of three dots  or more are legal in Unix.In addition, in Windows and DOS utilities, some words are also reserved and cannot be used as filenames. For example, DOS device files:Systems that have these restrictions cause incompatibilities with some other filesystems. For example, Windows will fail to handle, or raise error reports for, these legal UNIX filenames: aux.c, q"uote"s.txt, or NUL.txt.NTFS filenames that are used internally include:Forbids the use of characters in range 1-31  and characters " * / : < > ? \ | unless the name is flagged as being in the Posix namespace. NTFS allows each path component  to be 255 characters long.Windows forbids the use of the MS-DOS device names AUX, CLOCK$, COM0, …, COM9, CON, LPT0, …, LPT9, NUL and PRN, as well as these names with any extension , except when using Long UNC paths .  The Win32 API strips trailing period , and leading and trailing space characters from filenames, except when UNC paths are used. These restrictions only apply to Windows; in Linux distributions that support NTFS, filenames are written using NTFS's Posix namespace, which allows any Unicode character except / and NUL."Qualified" contains . after every 8 characters or fewer. Partitioned data sets  are divided into members with names of up to 8 characters; the member name is placed in parenthesises after the name of the PDS, e.g. PAYROLL.DEV.CBL